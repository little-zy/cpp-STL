
# C++ Primer v5
[TOC]

## 可以<font color=red>在声明中</font>使用默认参数
## 使用引用参数
可以在函数调用时使用引用参数：通过形参改变实参的值.

常引用：`const Time &t`

## 构造函数与析构函数相当于栈
- 先构造的后析构，后构造的先析构。
- 先定义的先初始化
## 指向对象成员函数的指针需要属于该类,继承例外。
如：
```c++
void (Point :: *p)();
p为指向Point类公用成员函数的指针。

注意：不能写成void Point:: *p() = void(Point:: *(p()))
这是返回值为void型指针的函数。
```
## 常成员函数
```c++
　　void get_time() const;
    他可以修改的是这种变量：
　　mutable int count;
```
##　复制构造函数

- `Box box2(box1)；`编译器自动实现。
- 函数返回值为对象时，注意其生存期，好在编译器会自动复制。
- 自己定义时注意，调用push（）前应初始化_size等为0
## 静态数据成员
```c++
static int height;
所有成员共用，一变全变。
int Box::height= 10;        //只能在类外初始化,可以通过类名、对象名引用。
```
## 静态成员函数
- 主要用来访问静态成员。
- 可以通过类名、对象名引用。
## 友元类
- `Friend 类名；`
- 单向性。不可传递性。
- 很少用。
## 模板
```c++
　　template <typename T1> 
　　T1 max(T1 a, T1 b, T1 c) {
    if (b > a) a= b;
    if (c > a) a= c;
    return a;
}
类模板：template <class NAME>
```
## 重载流输出
```c++
    friend ostream& operator<<(ostream&, const Point&);

    ostream& operator<<(ostream& output, const Point& p) {
　　　　　output << "[ " << p.x << " , " << p.y << " ]";
　　　　　return output;
　　}
```
- 如果运算符函数重载为成员函数，它的第1个参数必须是本类的对象。当第1个操作数不是类对象时，不能将运算符函数重载为成员函数。如果将运算符“＋”函数重载为类的成员函数，交换律不适用。 由于这个原因，一般情况下将双目运算符函数重载为友元函数。单目运算符则多重载为成员函数。  
## 	重载++
```c++
CDemo CDemo::operator++()    //前置 ++
{                           
    n++;                    
    return *this;           
}                           
CDemo CDemo::operator++(int) //后置 ++
{                           
    CDemo tmp(*this);        //记录修改前的对象
    n++;                    
    return tmp;              //返回修改前的对象
}              
```
## 类型转换
```c++
int(2.5) == (int)2.5;
```

还有转换构造函数：
```c++
Complex(double r)
{
    real= r;
    image= 0;
}
Complex　c= Complex(3.6);
```

类型转换函数
```c++
operator double(){
    return real;
}
```
## 访问基类私有数据
派生类的对象不能访问基类私有数据，但派生类的成员函数可以通过调用基类的公用成员函数来访问基类私有数据。
##　默认构造函数为什么会失效
- 含有复合类型或者内置类型的成员
- 编译器把它定义为删除的：
某个成员的析构函数、拷贝构造函数或者拷贝赋值运算是删除的或者不可访问（private）
## `class`和`struct`仅仅是形式上的不同
唯一区别就是在第一个访问说明符前，`class`默认`private`，`struct`默认`public`。

默认的继承保护级别也是一样。
## 访问说明符
访问说明符出现的位置和次数没有限定。
## 友元不是类的成员
友元函数声明可以出现在类定义内的任何位置，其访问控制级别不受所在区域的约束。
## 拷贝构造函数的参数必须是引用类型
- 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。

- 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功一为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。
## 编译器实现访问控制
可能是通过设置为`=delete`;
## 赋值运算符的重载

注意自赋值。
```c++
Point& Point::operator=(const Point &po){
    auto newp= new string(*po.s);
    delete s;
    s= newp;
    i= po.i;
    return *this;
}
```
## 派生类必须使用其基类构造函数来初始化其基类部分
## 派生类对基类赋值
- 用派生类对基类赋值时，只保留基类部分。

## 虚函数
- 基类中希望派生类各自定义的函数。

- 虚函数必须有定义，派生类也必须将其重新声明，且其形参类型和返回类型要与基类一致。

- 如果某函数的执行与派生类的细节无关，则可以不定义成虚函数，且该函数所访问的数据也可以设置成`private`。

- 基类中的虚函数在派生类中也是虚函数。

## 动态绑定
虚函数中，由于基类的引用和指针可以指向派生类，因此允许在运行时再确定该引用或指针所指的对象。这种现象叫动态绑定。这种类型叫动态类型。

OOP的核心思想是多态性。
引用或指针的静态类型与动态类型不同，这正是C++支持多态性的根本所在。
## 派生类的同名函数 
定义在派生类的同名函数不会重载基类函数，而是隐藏它。
所以才需要虚函数?
## `protected`
基类希望它的派生类有权访问，同时禁止其他成员访问。
## `using`
- `private`继承中，可用`using Base::size`解除限制
- 因为`using`只要指定名字而不是参数列表，因此可以把该函数所有可访问的重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数。
## 关键概念

>不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码使用类的对象，这部分代码只能访间类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。
>
>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。
>
>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。


## 纯虚函数

后置`=0`，说明当前类下该虚函数没有意义，无须定义。

含有纯虚函数的类叫抽象基类，抽象基类不能定义对象。

## `override`和` final`
`override`可以确认与基类的虚函数一致。
`final`可以防止类的继承和函数的覆盖。

## 虚基类
通过虚继承，保证无论在继承体系中继承多少次，在派生类中都只包含一个基类。比较复杂。